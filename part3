import java.util.*;
import java.lang.*;
import Coordinates;

public class part3
{


static int[][] grid;
static char[][] knwgrid;
static int[][] ggrid;
static double[][] huegrid;
static double[][] fgrid;
static String path="";
static Coordinates prev;
PriorityQueue<Coordinates> openlist= new PriorityQueue<Coordinates>();
LinkList<Coordinates> closedlist = new LinkList<Coordinates>();

  public static void main(Strings[] args)
  {
    final int DIM=3;
    final double P=.1;
    
    // we need to keep track of some stuff so just use arrays to do that
    //initialize stuff
    
    intGrid(DIM, P);
    intAllgrids(DIM);
    //start at 0,0
    
    Coordinates start= new Coordinates(0,0,DIM);
    prev= new Coordinates(0,0,DIM);
    boolean status = true;
    
    while(!status)
    {
    	path = "";
    	Coordinates start= new Coordinates(0,0,DIM);
	status = ASTAR(start);
	openlist.clear();
	closedlist.clear();
	
    }
    // path should have the last ordered pair of destination if not failure
    if(path.charAt(DIM-1)== (char)DIM)
    {
    	System.out.println("a solution was found by: \n\n"+path+" path\n");
    }
    else
    {
       System.out.println("\n no path was found:\n");
    }
   }
   
   public boolean ASTAR( Coordinates point)
   {
   	int x= point.x;
	int y=point.y;
	closedlist.add(point);
	
	knwgrid[x][y]= (char)grid[x][y];
	// you hit a wall repeat
	
	if(grid[x][y]==1)
	{
		return false;
	}
	
	// there is no solution stop
	if(!(path.isEqual("")) && openlist.isEmpty() && validAdj(point).isEqual("0000"))
	{
		return true;
	}
	else
	{
		path= path+""+x+""+y+"";
		
		// you finished stop
		if(x==y && (y==(point.dim-1) )  )
		{
			// great we are at the destination
			return true;
		}
		// now we have work...
		// we need to find valid edges compute g f and hue and add to the queue
	
		
		// hue is already set so now we can go straight to g
		// this g formula is probably bad but it should not effect overal ability
		if(x==y && y==0)
		{
			ggrid[x][y]=(dim-1)*2;
		else
		{
			ggrid[x][y]=Math.max((ggrid[prev.x][prev.y]-1),((dim-1)*2-x-y));
		}
		String check= validAdj(point);
		
		if(check.charAt(0)==1)
		{
			Coordinates temp1= new Coordinates(x-1,y,point.dim);
			
		}
		if(check.charAt(1)==1)
		{
			Coordinates temp2= new Coordinates(x,y+1,point.dim);
		}
		if(check.charAt(2)==1)
		{
			Coordinates temp3= new Coordinates(x+1,y,point.dim);
		}
		if(check.charAt(3)==1)
		{
			Coordinates temp4= new Coordinates(x,y-1,point.dim);
		}
		
			
	
   
   }
    
    
    // kind of confusing basically it returns a binary string '0000'
    //where bits 0-3 are up right down left repectivly are valid adjacent neighbors of 
    // some point in the KNWGRID not the actual grid. ? is considered a valid neighbor
    // but 1, and out of bounds is not.
    
    // i added this later it will also check if the point is IN THE CLOSEDLIST if it is its zero
    
  public String validAdj(Coordinates point)
  {
  	int x=point.x;
	int y=point.y;
	int dim = point.dim;
	
	char[] r = {'1','1','1','1'};
	
	if( (x-1) <0 || knwgrid[x-1][y]==1 || (closedlist.contains(point.setThis((x-1),y)))
	{
		r[0]='0';
	}
	if( (x+1)>=dim || knwgrid[x+1][y] ==1 || (closedlist.contains(point.setThis((x+1),y)))
	{
		r[2]='0';
	}
	if( (y-1) <0 || knwgrid[x][y-1]==1 || (closedlist.contains(point.setThis(x,(y-1))))
	{
		r[3]='0';
	}
	if( (y+1)>=dim || knwgrid[x][y+1] ==1 || (closedlist.contains(point.setThis(x,(y+1)))
	{
		r[1]='0';
	}
		
	point.setThis(x,y);
	
	return ""+r[0]+r[1]+r[2]+r[3]+"";
	
	
  }


  // 
  
  //nvm made them all one thing
  public void intAllgrids(int dim)
  {
     knwgrid= new char[dim][dim];
     huegrid= new double[dim][dim]; 
     fgrid= new double[dim][dim];
     ggrid= new double[dim][dim];
     
     
     for(int i =0;i<dim;i++)
     {
      for(int j=0;j<dim;j++)
        {
          knwgrid[i][j]='?';
	  ggrid[i][j]= 0;
	  huegrid[i][j]= (Math.sqrt(Math.pow((i-point.dim),2)+Math.pow((j-point.dim),2)))+
				  Math.abs(i-point.dim)+Math.abs(j-point.dim) +
				  Math.max( Math.abs(i-point.dim),Math.abs(j-point.dim) ))/3.0 ;;
	  fgrid[i][j]=-1.0;
	  
        }
     }
     knwgrid[0][0]='0';
     knwgrid[dim-1][dim-1]=0;
  }
public static void intGrid(int n, double p) {
		int [][] arr= new int [n][n];
		double rand;
		for(int i=0;i<n;i++) {
			for(int j=0;j<n;j++) {
				if(i==0 && j==0) {
					arr[i][j]=0;
					continue;
				}
				if(i==n-1 && j==n-1) {
					arr[i][j]=0;
					continue;
				}
				rand=Math.random();
				if(rand<=p) {
					arr[i][j]=1;
				}
				if(rand>p) {
					arr[i][j]=0;
				}
			}
		}
		grid= arr;
	}

  /* 
  public int[][] flipForFour(int[][] start, int dim)
  {
    int[][] flippped = new int[dim][dim];
    int i=0;
    int j=0;
    
    for(i=0;i<n;i++)
    {
      for(j=0;j<n;j++)
      {
          flipped[n-1-i][n-1-j]=start[i][j];
      }
    }
    return flipped;
  }
  */
  
}
